1.	判断题
1.	多线程访问同一个可变变量需增加同步机制。（对）
	对
	错
2.	String str=new String("string") 会造成资源浪费，重复创建。（对）
	对
	错
3.	记录异常的日志应为error或fatal （对）
	对
	错
4.	不建议java程序访问windows注册表，如果必须，也不建议使用native method访问（对）
	对
	错
5.	建议通过thred.stop方法终止线程运行（错）
	对
	错
6.	声明一个带泛型的类或接口的时候，建议限制可以用的泛型类型，避免接口使用者乱用（对）
	对
	错
7.	避免对第三方代码的强依赖或陷入第三方代码细节（对）
	对
	错
8.	根据java language specification中对java内存模型的定义，每个线程都有自己的工作内存(Working Memory)线程间的变量访问需要通过主内存完成（对）
	对
	错
9.	多线程操作同一个字符串相加，就采用stringbuilder （错）
	对
	错
10.	英文字符串的大小写转换，必须使用locale.ENGLISH（对）
	对
	错
11.	方法命名无法表达的信息，必须加方法头注释辅助说明；禁止空有格式的方法头。（对）
	对
	错
12.	不应该随意进行类型转换，应改善涉及，或在转换前用instanceof（对）
	对
	错
13.	相比匈牙利命名风格，驼峰将类型与命名解耦合，功能更单一（对）
	对
	错
14.	写注释时要换位思考，用注释去表达此时读者真正需要的信息。在代码的功能、意图层次上进行注释，即注释解释代码难以表达的意图，不用重复代码信息（对）
	对
	错
15.	在业务流程中，可以使用异常机制来做流程控制（错）
	对
	错
16.	为了保证每个模块都是单一职责，文件不要超过2000行（对）
	对
	错
17.	不用的代码段不删除而注释保留，可以为后续可能的使用提供便利（错）
	对
	错
18.	在中文windows环境下，配置文件应采用默认的GBK编码（错）
	对
	错
19.	直接捕获基类异常exception可以减少代码量，方便以后维护（错）
	对
	错
20.	为了提高代码的可读性，一行代码越长越好，这样不用换行阅读（错）
	对
	错
21.	禁止使用GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中（ 对）
	对
	错
22.	一个局部变量只应该表达一种含义（对）
	对
	错
23.	静态成员方法可以在子类与父类间覆写（override）（错）
	对
	错
24.	可以在单个的表达式中对相同的变量赋值超过一次（错）
	对
	错
25.	优秀的代码尽量通过符号命名自我解释，然后按需辅以注释（对）
	对
	错
26.	正式交付给客户的代码不能包含TODO/TBD/FIXME注释（对）
	对
	错
27.	推荐全用本地方法（native method），以提升系统性能（错）
	对
	错
28.	在接口定义中，属性已缺省具有public static final修饰词，方法已缺省具有public abstract （对）
	对
	错
29.	调用重载的方法是在编译期确定的（对）
	对
	错
30.	如果输入源或输出目标直接支持，尽可能直接使用Unicode进行输入输出。（对）
	对
	错
31.	使用线程安全集合可以在多线程间共享可变数据，替代传统的synchronized关键字（对）
	对
	错
32.	方法尽量通过方法签名自注释，按需写方法头注释（对）
	对
	错
33.	建议通过java1.5提供的新并发工具代替wait和notify（对）
	对
	错
34.	类和方法的设计可优先考虑泛型（对）
	对
	错
35.	代码注释放于对应代码的上方或右边或下方。（错）
	对
	错

36.	为了提升性能，可以不加控制的创建新线程（错）
	对
	错
37.	可以不对第三方抛出的异常进行封装，这样可以直接利用第三方的异常来处理（错）
	对
	错
38.	所有方法都要加方法头注释（错）
	对
	错
39.	推荐使用本地方法(native method)，以提升系统性能（错）
	对
	错
40.	为了适配采用默认字符编码的遗留系统，建议直接改用默认字符编码（错）
	对
	错
41.	注释内容要简洁、明了、无二义性，信息全面且不冗余（对）
	对
	错
42.	使用泛型，当从集合类中读取一个对象时，就不用手工进行类型转换（对）
	对
	错
43.	Case语句应该尽可能短，不影响整体条件分支处理逻辑；如果长了，应该考虑封装方法（对）
	对
	错
44.	注释符与注释内容间不要有空格（错）
	对
	错
45.	对于类的访问控制块的声明顺序应该是private，protected,public（错）
	对
	错
46.	代码中的注释、字符串、日志等，如果是中文应该无错误字、语句通顺，如果是英文应该拼写无误、语法正确（对）
	对
	错
47.	注释一定要以满足“代码注释率”为目标（错）
	对
	错
48.	每个方法都必须要有方法头注释（错）
	对
	错
49.	异常可以减少代码嵌套的层次，而错误码会增加代码的嵌套（对）
	对
	错
50.	将变量设置为私有(private)的原因在于封装类内部实现细节。（对）
	对
	错
51.	必须在代码中硬编码“\n”和“\r”作为换行符号（错）
	对
	错
52.	创建线程时指定线程名的好处之一是方便问题定位（对）
	对
	错
53.	建议通过Thread.stop方法终止线程运行（错）
	对
	错
54.	在程序中，允许空的catch块来忽略异常（错）
	对
	错
55.	可以通过使用JAVA的线程优先级来实现业务的优先级调度（错）
	对
	错
56.	与C++相同，在构造方法中调用的成员方法只可能是当前类的实现，不可能被子类覆盖（错 ）
	对
	错
57.	新代码不要使用已标注为@Deprecated的方法（对）
	对
	错
58.	当抛出异常时，应该提供尽可能多的信息，以便分析“异常时如何产生的”（对）
	对
	错
59.	避免枚举常量序号的产生依赖于ordinal()方法（对）
	对
	错
60.	在集合类中我们推荐使用泛型，这样在编译的时候就会检查元素类型（对）
	对
	错
61.	注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，按需注释（对）
	对
	错
62.	浮点型数据可以使用==判断相等（错）
	对
	错
63.	序列化对象中的HashMap、HashSet或HashTable等集合可以包含对象自身的引用？（错）
	对
	错
64.	静态成员变量是属于某个对象实例，而不是属于类级别的变量（错）
	对
	错
65.	使用第三方提供的代码包时，建议使用Adapter模式，封装中间层，以避免第三方的变更对一有程序的影响（对）
	对
	错
66.	可以使用错误码来代替异常来做错误处理（错）
	对
	错
67.	字符串与字节数组之间的转换，应使用系统默认的编码方式（错）
	对
	错
68.	不应该随意进行类型强制转换，应改善设计，或在转换前用instanceof（对）
	对
	错
69.	不应该随意进行类型强制转换/临时变量（对）
	对
	错
70.	类和方法的设计可优先考虑泛型。（对）
	对
	错
71.	Case语句块结束时如果不加break，需要有注释说明(fall-through) （对）
	对
	错

72.	代码List objectList = new ArrayList(); //Incompatible types
	objectList.add(“I don’t fit in);
会产生ClassCastException异常。（错）
	对
	错
73.	右置注释与前面代码至少1空格（对）
	对
	错
74.	每个switch都必须要有default（错）
	对
	错
75.	对可恢复的情况使用受检异常（checked exception），对编程错误使用运行时异常（runtime exception）（对）
	对
	错
76.	一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明（对）
	对
	错
77.	为方便排错，在抛出异常的细节信息中包含能捕获失败的信息，但是不要包含敏感信息或者个人信息（对）
	对
	错
78.	Java8中可使用Optional代替null作为返回值或者可能的缺失值。（对）
	对
	错
79.	当方法只会抛出运行时异常（runtime exception）时，没有必要再方法注释中说明该异常（错）
	对
	错
80.	调用静态方法，可以使用实例或表达式来调用（错）
	对
	错
81.	为了提高代码的简洁性，请尽量使用缩写（错）
	对
	错

82.	像写普通代码注释一样去写方法头注释，写真正需要读者阅读的方法头（对）
	对
	错
83.	所有方法都要加上方法头注释（错）
	对
	错
84.	在Java代码中，只能使用//方式的注释。（错 ）
	对
	错
85.	Java平台类库的String、BigInterger和BigDecimal属于不可变类（对）
	对
	错
86.	禁止使用主动GC(除非在密码、RMI等方面)，尤其是在频繁/周期性的逻辑中（对）
	对
	错
2.	单选题
1.	下面哪种是不规范的做法(B  )
A.	stringBuilder.append(System.lineSeparator());
B.	System.out.print(“Hello.world!\n”);
C.	System.out.print();
D.	System.out.print(“Hello.world!”);

2.	关于受检异常（checked exception），以下说法正确的是(A)
A.	可恢复的场景应该使用受检异常
B.	在难以恢复的情况下应该使用受检异常
C.	受检异常应该是RuntimeException的子类

3.	关于Thread.stop方法，说法正确的是( C)
A.	主要是跟应用场景有关，在特定场景下可以使用
B.	推荐使用
C.	它可能会导致数据不一致或遭到破坏
D.	调用Thread.stop是安全的

4.	建议使用()来做错误处理(B)
A.	日志
B.	异常
C.	错误码
D.	包装类
5.	正式交付给客户的代码，针对“TODO”注释，正确的做法是：( D)
A.	将所有“TODO”报例外处理
B.	将“TODO”改成“遗留”，防止工具上报又不会丢失这些遗留点
C.	直接删除“TODO”字眼，防止工具上报
D.	逐个评估“TODO”，按需要进行处理

6.	关于java线程调度器，说法正确的是( B)
A.	JAVA线程调度器是平台无关的，所以可以跨平台使用
B.	不要依赖线程调度器来决定程序的逻辑运行
C.	JAVA的优先级调度在不同操作系统上行为一致
D.	只要遵循相同的JVM规范，各个厂商实现的线程调度器功能都完全相同

7.	对于常量和枚举的命名，说法错误的是(  D)
A.	static final常量应该是全大写
B.	对于方法局部的常量，使用小驼峰
C.	常量和枚举的值全大写时，应该使用下划线进行单词链接
D.	枚举的值和类型一样，应该都是大驼峰的

8.	关于方法命名描述错误的是( C )
A.	方法的命名要符合英文的阅读习惯
B.	避免使用无意义或者含义不清的单词为方法名
C.	方法命名禁止使用单词缩写
D.	方法的命名要准确描述方法功能

9.	PECS指“Producer Extends, Consumer Super”。如果参数化类型表示一个生产者，就使用（）；如果它表示一个消费者，就使用（A）
A.<? extends T> ,<? super T>
B. <? super T> ,<? extends T>
C.<T1> ,<T2>

10.	建议方法的参数个数不能超过（D）个
A.7
B.8
C.6
D.5

11.	关于线程异常，说法正确的是：（A）
A.	可以通过Thread对象提供的setUncaughtExceptionHandler方法获取线程中产生的异常
B.	线程异常由JVM虚拟机捕获和处理，开发者不需要关心
C.	只要抛出unchecked exception，线程就必须结束运行
D.	线程不应该捕获unchecked exception

12.	如果一个对象存入Hash集合后hashcode随即发生变化，会导致什么结果？（A）
A．	内存泄露
B．	未知异常
C．	内存溢出
D．	无任何问题

13.	在保证代码风格一致性的基础上，下面哪些风格适用于成员变量（B）
A．	int filesize;
B．	int fileSize;
C．	int m_fileSize;
D．	int fileSize;

14.	代码private final Collection stamps = …;( C )
A.	执行时
B.	加载时
C.	编译时

15.	关于volatile的说法，正确的是：( B )
A.	可以完全代synchronized关键字
B.	对volatile修饰的变量的修改，其他线程可见
C.	被volatile修饰的变量多线程并发修改是安全的
D.	volatile关键字经常用在多个线程并发写、某个线程只读的场景

16.	父类的构造方法中调用可能被子类覆写的方法造成的后果可能是( A  )
A.	子类包含的对象还未生成，导致NullPointerException异常
B.	子类对象还未生成，不可能调用到子类方法
C.	父子类方法都无法调用到
D.	只可能调用到当前类的成员方法，没有问题

17.	以下关于equals方法和hashcode方法描述错误的是( D )
A.	同一次运行中，同一个对象如果equals方法中用到的信息没有改变，多次调用hashCode方法返回值必须相同
B.	如果两个对象调用equals方法时相等，则这两个对象的hashCode方法，也必须返回相同的值
C.	如果两个对象调用eqals方法时不相等，则这两个对象的hashCode方法，不要求其返回值不同
D.	“覆写equals方法时，应同时覆写hashCode方法”的好处是为了提升查询效率
18.	不影响业务进行的错误用（D）级
A.	debug级
B.	error级
C.	info级
D.	warn级

19.	方法的命名，说法错误的是（ D ）
A．	方法采用小驼峰
B．	方法采用动宾结构
C．	方法采用动词
D．	方法采用大驼峰

20.	下面的代码的运行结果是（ C ）
 
A.	打出异常堆栈
B.	aa：bb
C.	aa：1

21.	对于类型命名，下面写法错误的是：（ A ）
A．	interface file
B．	class ParkingLot
C．	enum FileType
D．	abstract class PropertiesMap

22.	需要精确计算时建议使用类型（ C ）
A．	都可以
B．	float
C．	都不可以
D．	double

23.	以下代码可能存在什么问题：（ D ）
 
A．	数组越界
B．	没毛病
C．	内存溢出
D．	内存泄露

24.	对于如下代码，描述正确的是？（ B ）
 
A．	缺少一个default：子句
B．	缺少一个收尾的else语句块
C．	没毛病
25.	对待第三方API抛出的各类异常时，以下说法正确的是（ B ）
A.	捕获后不处理
B.	捕获并转换成相应的业务异常
C.	不做处理，继续抛出

26.	一般业务处理日志用（C）级
A.	warn级
B.	debug级
C.	info级
D.	error级

27.	关于魔鬼数字，说法正确的是：（ C ）
A.	0、1、-1肯定不是魔鬼数字
B.	所有的数字都是魔鬼数字
C.	难以理解的数字是魔鬼数字
D.	100肯定是魔鬼数字

28.	下面哪段代码不会导致内存泄漏：B
A.	public <T> pop() {if (size == 0) {throw new EmptyStackException();} return elements[--size];}
B.	public <T> pop() {if (size == 0) {throw new EmptyStackException();} T result = elements[--size]; elements[size]=null;return result;}

29.	避免方法的代码块嵌套过深，不要超过（ D）层
A.	3
B.	5
C.	2
D.	4
30.	异常机制不应用于处理以下哪种情况？（ B ）
A.	正常流程无法正常运行
B.	业务流程控制
C.	罕见的错误
D.	意料之外的情景

31.	为了保证代码的缩进统一，建议每次缩进是几个空格（ C ）
A.	8个空格
B.	2个空格
C.	4个空格
D.	1个Tab符

32.	一般的业务处理日志用（ C ）级
A．	debug级
B．	error级
C．	info级
D．	warn级

33.	关于变量初始化，说法正确的是（ C ）
A.	任何情况变量定义时都要初始化
B.	可以使用未经初始化的变量
C.	变量按需初始化
D.	冗余初始化更安全

34.	方法的长度建议不超过( B )行
A.	120
B.	50
C.	100
D.	80

35.	在Java1.5+，在不需要索引的场景，我们应使用（ D ）替代传统的for循环？
A.	do{}while()
B.	iterator
C.	索引for()
D.	for-each

36.	什么时候需要增加空行（ D ）
A.	注释行之后
B.	变量定义之前
C.	方法调用之后
D.	相对独立的程序快之间

37.	关于方法命名，说法错误的是（ A ）
A.	方法采用大驼峰
B.	方法采用动宾结构
C.	方法采用小驼峰
D.	方法采用动词

38.	关于线程安全性的文档说明，说法错误的是：（ B ）
A.	它是于其调用者程序建立的约定的重要组成部分
B.	主要作用是为了以后自己维护代码方便
C.	不需要使用者对这个类的线程安全性做假设
D.	不提供文档说明容易导致过度同步或者没有同步，引起严重的功能或者性能问题

3.	多选题
1.	Jdk1.5版本中初次引入Varargs (variable number of arguments)可变数量参数，可以接受指定类型的零到多个参数。使用可变数量参数的方法时注意：（ CD ）
A.	不应该在确实需要操作可变长度的值的序列时使用
B.	建议使用varargs重用使用一个固定长度数组作为参数的方法
C.	不建议使用varargs重写使用一个固定长度数组作为参数的方法
D.	应该在确实需要操作可变长度的值的序列时使用

2.	关于大括号的使用，说法正确的是：（ ACD ）
A．	if/while/switch/for 语句的左大括号跟随放行末
B．	方法作大括号另起并独占一行
C．	左大括号放行末时，其前方要保持1空格
D．	if/while/switch/for语句必须要有大括号

3.	使用包装类型合理的场景有：（ ACD ）
A.	泛型，必须使用包装类型
B.	定义常量时
C.	进行反射的方法调用时
D.	作为集合中的元素、键和值

4.	子类覆写父类方法时应加上@Override注解的好处是：（ BD ）
A.	方便运行期检查
B.	如果覆写时因为疏忽，导致子类方法的参数同父类不一致，编译时会报错，使问题在编译期就被发现
C.	只有加了@Override注解才能达到覆盖夫类方法的目的
D.	如果父类修改了方法定义造成子类不再覆写父类方法，能使问题在编译期尽早被发现

5.	对于类型命名，下面说法正确的是（ ABCD  ）
A.	接口的命名应该是大驼峰
B.	枚举的命名应该是大驼峰
C.	注解类型应该是大驼峰
D.	类的命名应该是大驼峰

6.	下面哪些变量命名是推荐的 （ ABD ）
A.	int lineCount;
B.	int udpConnectionCount;
C.	int a;
D.	int bookId;


7.	关于受检异常(checked exception)、运行时异常(runtime exception)、错误(Error)，以下说法正确的是（ ABCDE ）
A.	除非必要时，最好不要实现新的Error子类
B.	受检异常可以强迫调用者在一个catch子句中处理该异常，或者继续向外传播
C.	错误（error）被JVM保留用于指示资源不足、约束失败或者其他程序无法继续执行的情况
D.	如果期望调用者能够恢复，则应该使用受检异常
E.	运行时异常是指难以恢复或者不可恢复的程序错误

8.	尽量不要实现Serializable接口的原因是？（ ABCDF ）
A．	序列化不必要地对外公开了对象的物理实现
B．	序列化增大了安全风险
C．	序列化增加了测试的难度
D．	序列化容易使一个类对其最初的内部表示产生依赖
E．	Serializable接口在Java8中已经被标注为deprecated
F．	编写正确的反序列化代码有很大的挑战

9.	下面的命名中适合小驼峰的有哪些？（ ABCD ）
A．	方法
B．	类的字段
C．	方法参数
D．	局部变量

10.	如下例子，当names为()时，会可能出现性能问题而非可靠性问题？（ BD  ）
 
A.	names为null
B.	names为Vector实例
C.	names的size为0
D.	names为LinkedList实例
11.	请问如下哪些序列化的实现类，不是最优的？（ BCD ）
A．	public class OhMyGod implements Serializable {public static final long serialVersionUID =-2589766491699675794L;}
B．	public class OhMyGod implements Serializable {private static final long serialVersionUID =-2589766491699675794L;}
C．	public class OhMyGod implements Serializable {private final long serialVersionUID =-2589766491699675794L;}
D．	public class OhMyGod implements Serializable {private long serialVersionUID =-2589766491699675794L;}

12.	下面命名中适合大驼峰的有哪些？( AD  )
A.	接口
B.	方法
C.	static final常量
D.	类

13.	关于注释，如下描述正确的有（ABCDE ）
A．	注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，按需注释
B．	一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明
C．	注释内容要简洁、明了、无二义性，信息全面且不冗余
D．	写注释时要换位思考，用注释去表达此时读者真正需要的信息。在代码的功能、意图层次上进行注释。
E．	修改代码时，也要保证其相关注释的一致性。

14.	不可变类型是指其实力一旦创建后就不能被修改，要使类成为不可变类，需遵循的规则有：( ABCDE )
A.	如果类具有指向可变对象的域，则必须确保该类的使用者无法获得指向这些对象的引用
B.	保证类不会被继承
C.	不要提供任何会修改类状态的方法
D.	使所有值域都为final
E.	使所有值域都成为私有

15.	什么时候需要增加空格( ABD )
A.	注释符号注释内容之间
B.	if关键字后面
C.	变量与自增运算符（++）之间
D.	逗号，分号与后续内容之间

16.	正确使用异常机制事半功倍，以下说法正确的是( ABD )
A．	注释和文档中应该包含所抛出的异常说明
B．	异常机制不能取代正常的业务逻辑判断
C．	异常信息中可以包含敏感信息和个人信息
D．	方法抛出的异常，应该与本身的抽象层次相对应

17.	不用的代码直接删除掉，而不是注释掉，是因为：( ABC )
A.	注释掉的代码影响其他有用代码的阅读
B.	注释掉的代码无法被正常维护，不可信任
C.	单元测试、自动化测试等无法覆盖注释掉的代码，其中有可能隐藏缺陷

18.	关于行宽，描述正确的是：(ABC )
A.	比如代码中包括较长字符串，不宜截断，则可以例外，超过行宽
B.	通过简短的方法、变量命名，控制嵌套层数来努力让每行代码打到行宽要求
C.	代码行过长，则不利于阅读
D.	使用高分辨率显示器时，可以放松对行宽的要求

19.	关于空行的使用，说法正确的是：(ABC )
A.	相邻的两个方法定义之间的间隔使用空行
B.	根据上下内容的相关程度，合理安排空行
C.	大括号内的带啊块行首之前和行尾之后不要加空行

20.	我们推荐()实现常用的功能或算法(  BC  )
A.	自己编写代码
B.	使用广泛使用的开源库
C.	使用JDK自带的API

21.	关于异常，以下说法错误的是( ABD  )
A.	方法抛出的异常数量可以不受限制
B.	finally块中可以使用return、continue或者break进行流程控制
C.	方法抛出的异常，应该与本身的抽象层次相对应
D.	不用处理的异常可以使用空catch块进行忽略
